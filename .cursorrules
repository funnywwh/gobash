# gobash 项目 Cursor 规则

## 项目概述

gobash 是一个使用 Go 语言开发的兼容 Bash 语法的跨平台 Shell 程序，优先支持 Windows 平台。

### 核心组件
- **lexer**: 词法分析器，将源代码转换为 token 流
- **parser**: 语法分析器，构建抽象语法树（AST）
- **executor**: 执行器，解释执行 AST
- **builtin**: 内置命令实现
- **shell**: Shell 核心逻辑（交互式 REPL、脚本执行）

## 代码风格和规范

### Go 代码规范
- 遵循 Go 官方代码规范（gofmt）
- 使用有意义的变量和函数名
- 函数应该简短，单一职责
- 添加必要的注释，特别是公共 API

### 错误处理
- 使用 Go 标准的错误处理模式
- 错误信息应该清晰、可操作
- 对于致命错误，使用 `os.Exit(1)`

### 平台兼容性
- 优先支持 Windows，同时兼容 Linux 和 macOS
- 使用条件编译处理平台特定代码（如需要）
- 信号处理要考虑 Windows 限制（某些信号不可用）

## 架构原则

### 模块化设计
- 每个模块职责清晰
- 模块之间通过接口交互
- 避免循环依赖

### 执行流程
1. **词法分析**: `lexer` 将源代码转换为 token
2. **语法分析**: `parser` 将 token 流解析为 AST
3. **执行**: `executor` 遍历 AST 并执行

### 变量和环境变量
- 使用 `executor.Executor` 的 `env` map 存储环境变量
- 同时更新 `os.Setenv` 以保持一致性
- 特殊变量：`$#`, `$@`, `$*`, `$?`, `$!`, `$$`, `$0`, `$1`, `$2`, ...

## 已知问题和注意事项

### 当前已知问题

1. **算术展开在变量赋值中未正确处理**
   - ✅ 已修复：算术展开现在可以正确处理
   - ✅ 已修复：算术展开中的变量名可以直接使用（如 `$((j+3))`）

2. **引号内转义字符处理错误**
   - ✅ 已修复：`splitCommands` 现在正确处理引号内的转义字符
   - ✅ 已修复：`echo "\"\$((1+1))\"a"` 现在输出正确

3. **while 循环卡死**
   - 问题：循环中的变量无法更新，导致无限循环
   - 原因：算术展开未正确处理，变量赋值失败
   - 影响：所有使用 `$((...))` 的 while 循环都会卡死
   - 状态：可能已修复（算术展开问题已修复）

4. **信号处理**
   - 已修复：添加了信号处理，支持 Ctrl+C 中断
   - Windows 兼容性：`syscall.SIGTERM` 会被自动忽略，只使用 `os.Interrupt`

### 重要注意事项

1. **变量展开顺序**
   - 先处理转义序列（`\$`, `\"`）
   - 再处理算术展开（`$((...))`）
   - 最后处理变量展开（`$VAR`, `${VAR}`）

2. **引号内转义字符处理（关键规则）**
   - **引号内的转义字符必须保留**：由 lexer 处理，不能在前置处理中修改
   - **splitCommands 函数**：必须正确处理引号内的转义字符
   - **转义的引号**：`\"` 不应该被当作引号结束，应该保留为字面量
   - **转义的美元符号**：`\$` 在引号内应该保留，阻止变量展开

3. **算术展开特殊规则（关键规则）**
   - **变量名可以直接使用**：在 `$((...))` 中，变量名可以直接使用，不需要 `$` 前缀
   - **示例**：`$((j+3))` 中的 `j` 会被自动展开为变量值
   - **未定义变量**：在算术表达式中，未定义的变量被视为 `0`
   - **运算符关键字**：需要排除 `and`, `or`, `not`, `eq`, `ne`, `lt`, `le`, `gt`, `ge` 等运算符

4. **命令执行**
   - 前台命令使用 `Start()` + `Wait()` 而不是 `Run()`，以便处理信号
   - 后台命令使用 `Start()` 并添加到作业管理器

5. **脚本执行**
   - 自动跳过 shebang 行（`#!/bin/bash`）
   - 自动跳过注释行（以 `#` 开头）
   - 支持多行语句（case、if、for、while 等）

## 测试要求

### 测试文件位置
- 单元测试：`*_test.go` 文件（在各个模块目录中）
- 集成测试：`integration_test.go`（根目录）
- 脚本测试：`tests/test_*.sh` 文件
- 测试数据：`tests/test_*.txt` 文件
- 测试文档：`tests/test_summary.md`

### 测试脚本
- `tests/test_arithmetic_assignment.sh` - 测试算术展开
- `tests/test_while_loop.sh` - 测试 while 循环
- `tests/test_variable_expansion.sh` - 测试变量展开
- `tests/test_case_statement.sh` - 测试 case 语句
- `tests/test_build_script.sh` - 模拟 build.sh

### 运行测试
```bash
# 单元测试
go test ./...

# 脚本测试（从项目根目录运行）
./gobash tests/test_all.sh
# 或从 tests 目录运行
cd tests && ../gobash test_all.sh
```

## 开发流程和计划执行

### 严格按计划执行（必须遵守）
- **必须严格按照 REFACTOR_PLAN.md 中的计划一步一步执行**
- **必须按照计划文档中的顺序执行，不能跳过任何任务**
- **每次只完成计划中的一个任务或一组相关任务**
- **完成一个任务后，必须更新计划文档，标记为已完成**
- **在开始新任务前，必须查看计划文档，确认下一步要做什么**
- **绝对不要跳过计划中的任务，即使看起来很简单或已经部分实现**
- **如果计划中的任务太大，可以拆分成更小的子任务，但必须记录在计划文档中**
- **完成每个阶段后，必须运行所有测试，确保没有回归**
- **每次完成重要任务后，必须提交并推送代码**

### TDD 驱动开发（必须遵守）
- **所有新功能必须遵循 TDD（测试驱动开发）流程**
- **先编写测试用例，确保测试失败（Red）**
- **然后实现功能，使测试通过（Green）**
- **最后重构代码，保持测试通过（Refactor）**
- **测试不通过不能跳过，必须修复直到所有测试通过**
- **每个功能都要有对应的测试用例**
- **运行测试确保没有回归：`go test ./...`**

### 任务完成标准（必须遵守）
- **不能部分实现：任务必须完全完成，不能标记为"部分完成"**
- **不能跳过：即使任务复杂或困难，也必须完成，不能跳过**
- **复杂任务分解：如果任务太大，必须拆分成更小的子任务，并更新计划文档**
- **验证完成：完成功能后必须运行测试验证，确保功能正确**
- **更新文档：验证通过后必须更新 REFACTOR_PLAN.md，标记任务为已完成**
- **提交推送：验证通过并更新文档后，必须提交并推送代码**
- **不能让人类做选择：AI 必须按照计划和规则自动执行，不要询问用户选择**

### 执行流程（严格遵循）
1. **查看计划文档**：读取 REFACTOR_PLAN.md，找到下一个未完成的任务
2. **编写测试**：如果是新功能，先编写测试用例（TDD）
3. **实现功能**：实现功能，确保测试通过
4. **运行测试**：运行所有相关测试，确保没有回归
5. **更新文档**：更新 REFACTOR_PLAN.md，标记任务为已完成
6. **提交推送**：提交代码并推送到远程仓库
7. **继续下一个**：自动继续下一个任务，不要询问用户

### 任务执行顺序（严格遵循）
1. **查看 REFACTOR_PLAN.md**，确定当前阶段和待完成的任务
2. **按照计划文档中的顺序**，选择下一个待完成的任务（必须是计划中标记为 "pending" 或 "in_progress" 的第一个任务）
3. **不能跳过**：即使某个任务看起来已经部分实现，也必须按照计划完成它
4. **实现任务**：完成选定的任务
5. **运行测试**：确保所有测试通过
6. **更新计划文档**：标记任务为已完成 `[x]`
7. **提交代码**：如果任务完成，提交并推送
8. **继续下一个任务**：按照计划顺序继续，不能跳过

### 计划文档维护
- 每次完成任务后，必须更新 REFACTOR_PLAN.md
- 在计划文档中标记已完成的任务为 `[x]`
- 更新进度状态（如 "进行中"、"已完成"）
- 记录完成日期和重要变更

## 修复问题时的指导原则

### 调试方法论（必须遵守）

1. **从更高视角审视代码**：不要局限于单个函数，要从整个数据流角度分析
   - 数据流路径：`Main → Shell.executeLine → splitCommands → executeCommand → Lexer → Parser → Executor → 输出`
   - 在关键位置添加调试输出：`fmt.Fprintf(os.Stderr, "[DEBUG] 函数名: 输入=%q, 输出=%q\n", input, output)`

2. **系统性调试流程**：
   - 重现问题（最小化测试用例）
   - 添加调试输出追踪数据流
   - 对比 bash 和 gobash 的行为差异
   - 定位根本原因（不要只修复症状）
   - 修复并验证

3. **调试工具**：
   - `od -An -tx1 -c` 查看字节序列
   - `bash -c 'command'` vs `./gobash -c 'command'` 对比
   - `git diff` 对比修改前后

### 关键规则（基于实际 bug 修复经验）

#### 引号内转义字符处理（关键规则）
- **引号内的转义字符必须保留**：由 lexer 处理，不能在前置处理中修改
- **splitCommands 函数**：必须正确处理引号内的转义字符，不能把 `\"` 误判为引号结束
- **转义的引号**：`\"` 不应该被当作引号结束，应该保留为字面量
- **转义的美元符号**：`\$` 在引号内应该保留，阻止变量展开

#### 算术展开特殊规则（关键规则）
- **变量名可以直接使用**：在 `$((...))` 中，变量名可以直接使用，不需要 `$` 前缀
- **示例**：`$((j+3))` 中的 `j` 会被自动展开为变量值
- **未定义变量**：在算术表达式中，未定义的变量被视为 `0`
- **运算符关键字**：需要排除 `and`, `or`, `not`, `eq`, `ne`, `lt`, `le`, `gt`, `ge` 等运算符

#### 变量展开顺序
1. 先处理转义序列（`\$`, `\"`）
2. 再处理算术展开（`$((...))`）
3. 最后处理变量展开（`$VAR`, `${VAR}`）

### 修复常见问题

**算术展开问题**：
- 检查 `expandVariablesInArithmeticExpression` 是否处理无 `$` 前缀的变量名
- 确保算术表达式被正确计算

**转义字符问题**：
- 检查 `splitCommands` 是否正确处理引号内的转义字符
- 确保引号内的转义字符不被误判为引号结束

**循环问题**：
- 确保循环中的变量赋值正常工作
- 检查条件判断中的变量展开

**添加新功能**：
- 先添加单元测试（TDD）
- 实现功能并运行所有测试
- 更新文档

## Bash 兼容性要求

### 必须支持的功能
- 基本命令执行（外部命令、内置命令）
- 管道和重定向（`|`, `>`, `<`, `>>`）
- 变量展开（`$VAR`, `${VAR}`）
- 命令替换（`` `command` ``, `$(command)`)
- 算术展开（`$((expr))`）
- 控制流（if/else, for, while, case）
- 函数定义和调用

### 平台限制
- Windows 不支持 `Ctrl+Z` 信号处理（平台限制）
- 某些 Unix 特性在 Windows 上可能表现不同

## 代码审查检查清单

修改代码时，确保：
- [ ] 代码符合 Go 规范（运行 `go fmt`）
- [ ] 没有 linter 错误（运行 `go vet`）
- [ ] 单元测试通过
- [ ] 相关脚本测试通过
- [ ] 平台兼容性（Windows/Linux/macOS）
- [ ] 错误处理正确
- [ ] 添加必要的注释

## 常见命令

### 构建
```bash
go build -o gobash ./cmd/gobash
```

### 运行测试
```bash
go test ./...
./gobash test_all.sh
```

### 代码检查
```bash
go fmt ./...
go vet ./...
```

## 文件结构

```
gobash/
├── cmd/gobash/          # 主程序入口
├── internal/
│   ├── lexer/          # 词法分析器
│   ├── parser/         # 语法分析器
│   ├── executor/       # 执行器
│   ├── builtin/        # 内置命令
│   └── shell/          # Shell 核心逻辑
├── pkg/
│   └── platform/       # 平台相关代码
├── tests/              # 测试脚本目录
│   └── test_*.sh       # 测试脚本
└── .cursorrules        # 本文件
```

## 调试技巧

### 基本方法
- 使用 `fmt.Fprintf(os.Stderr, "[DEBUG] ...")` 添加调试输出
- 使用 `./gobash -c "command"` 测试单个命令
- 对比 `bash -c 'command'` 和 `./gobash -c 'command'` 的输出

### 问题定位策略
- **从输出倒推**：从错误输出倒推，找到问题出现的第一个位置
- **数据流追踪**：在关键位置添加调试输出，追踪数据在每一层的变化
- **最小化测试用例**：创建最简单的测试用例，隔离问题

### 常见问题模式
1. **引号内转义字符被错误处理** → 检查 `splitCommands` 等预处理函数
2. **变量未展开** → 检查变量展开函数是否正确处理所有格式
3. **算术表达式计算错误** → 检查变量是否在计算前被正确展开
4. **字符串被截断** → 检查引号处理逻辑，特别是转义的引号

## 性能考虑

- 避免不必要的字符串复制
- 使用 `strings.Builder` 进行字符串拼接
- 对于大量数据，考虑使用流式处理

## 安全考虑

- 执行外部命令时，使用 `exec.Command` 而不是 `os/exec` 的字符串拼接
- 验证用户输入，避免命令注入
- 正确处理文件路径，避免路径遍历攻击

