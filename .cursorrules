# gobash 项目 Cursor 规则

## 项目概述

gobash 是一个使用 Go 语言开发的兼容 Bash 语法的跨平台 Shell 程序，优先支持 Windows 平台。

### 核心组件
- **lexer**: 词法分析器，将源代码转换为 token 流
- **parser**: 语法分析器，构建抽象语法树（AST）
- **executor**: 执行器，解释执行 AST
- **builtin**: 内置命令实现
- **shell**: Shell 核心逻辑（交互式 REPL、脚本执行）

## 代码风格和规范

### Go 代码规范
- 遵循 Go 官方代码规范（gofmt）
- 使用有意义的变量和函数名
- 函数应该简短，单一职责
- 添加必要的注释，特别是公共 API

### 错误处理
- 使用 Go 标准的错误处理模式
- 错误信息应该清晰、可操作
- 对于致命错误，使用 `os.Exit(1)`

### 平台兼容性
- 优先支持 Windows，同时兼容 Linux 和 macOS
- 使用条件编译处理平台特定代码（如需要）
- 信号处理要考虑 Windows 限制（某些信号不可用）

## 架构原则

### 模块化设计
- 每个模块职责清晰
- 模块之间通过接口交互
- 避免循环依赖

### 执行流程
1. **词法分析**: `lexer` 将源代码转换为 token
2. **语法分析**: `parser` 将 token 流解析为 AST
3. **执行**: `executor` 遍历 AST 并执行

### 变量和环境变量
- 使用 `executor.Executor` 的 `env` map 存储环境变量
- 同时更新 `os.Setenv` 以保持一致性
- 特殊变量：`$#`, `$@`, `$*`, `$?`, `$!`, `$$`, `$0`, `$1`, `$2`, ...

## 已知问题和注意事项

### 当前已知问题

1. **算术展开在变量赋值中未正确处理**
   - 问题：`i=$((1+1))` 输出 `i=1+1)` 而不是 `i=2`
   - 位置：`internal/parser/parser.go` 和 `internal/executor/executor.go`
   - 需要修复：parser 解析变量赋值时的算术展开 token 处理

2. **while 循环卡死**
   - 问题：循环中的变量无法更新，导致无限循环
   - 原因：算术展开未正确处理，变量赋值失败
   - 影响：所有使用 `$((...))` 的 while 循环都会卡死

3. **信号处理**
   - 已修复：添加了信号处理，支持 Ctrl+C 中断
   - Windows 兼容性：`syscall.SIGTERM` 会被自动忽略，只使用 `os.Interrupt`

### 重要注意事项

1. **变量展开顺序**
   - 先处理转义序列（`\$`）
   - 再处理算术展开（`$((...))`）
   - 最后处理变量展开（`$VAR`, `${VAR}`）

2. **命令执行**
   - 前台命令使用 `Start()` + `Wait()` 而不是 `Run()`，以便处理信号
   - 后台命令使用 `Start()` 并添加到作业管理器

3. **脚本执行**
   - 自动跳过 shebang 行（`#!/bin/bash`）
   - 自动跳过注释行（以 `#` 开头）
   - 支持多行语句（case、if、for、while 等）

## 测试要求

### 测试文件位置
- 单元测试：`*_test.go` 文件（在各个模块目录中）
- 集成测试：`integration_test.go`（根目录）
- 脚本测试：`tests/test_*.sh` 文件
- 测试数据：`tests/test_*.txt` 文件
- 测试文档：`tests/test_summary.md`

### 测试脚本
- `tests/test_arithmetic_assignment.sh` - 测试算术展开
- `tests/test_while_loop.sh` - 测试 while 循环
- `tests/test_variable_expansion.sh` - 测试变量展开
- `tests/test_case_statement.sh` - 测试 case 语句
- `tests/test_build_script.sh` - 模拟 build.sh

### 运行测试
```bash
# 单元测试
go test ./...

# 脚本测试（从项目根目录运行）
./gobash tests/test_all.sh
# 或从 tests 目录运行
cd tests && ../gobash test_all.sh
```

## 开发流程和计划执行

### 严格按计划执行（必须遵守）
- **必须严格按照 REFACTOR_PLAN.md 中的计划一步一步执行**
- **必须按照计划文档中的顺序执行，不能跳过任何任务**
- **每次只完成计划中的一个任务或一组相关任务**
- **完成一个任务后，必须更新计划文档，标记为已完成**
- **在开始新任务前，必须查看计划文档，确认下一步要做什么**
- **绝对不要跳过计划中的任务，即使看起来很简单或已经部分实现**
- **如果计划中的任务太大，可以拆分成更小的子任务，但必须记录在计划文档中**
- **完成每个阶段后，必须运行所有测试，确保没有回归**
- **每次完成重要任务后，必须提交并推送代码**

### 任务执行顺序（严格遵循）
1. **查看 REFACTOR_PLAN.md**，确定当前阶段和待完成的任务
2. **按照计划文档中的顺序**，选择下一个待完成的任务（必须是计划中标记为 "pending" 或 "in_progress" 的第一个任务）
3. **不能跳过**：即使某个任务看起来已经部分实现，也必须按照计划完成它
4. **实现任务**：完成选定的任务
5. **运行测试**：确保所有测试通过
6. **更新计划文档**：标记任务为已完成 `[x]`
7. **提交代码**：如果任务完成，提交并推送
8. **继续下一个任务**：按照计划顺序继续，不能跳过

### 计划文档维护
- 每次完成任务后，必须更新 REFACTOR_PLAN.md
- 在计划文档中标记已完成的任务为 `[x]`
- 更新进度状态（如 "进行中"、"已完成"）
- 记录完成日期和重要变更

## 修复问题时的指导原则

### 修复算术展开问题
1. 检查 parser 是否正确识别 `ARITHMETIC_EXPANSION` token
2. 检查 `expandVariablesInString` 是否正确处理 `$((...))`
3. 确保算术表达式被正确计算

### 修复循环问题
1. 确保循环中的变量赋值正常工作
2. 检查条件判断中的变量展开
3. 添加超时保护机制（如需要）

### 添加新功能
1. 先添加单元测试
2. 实现功能
3. 运行所有测试确保没有回归
4. 更新文档

## Bash 兼容性要求

### 必须支持的功能
- 基本命令执行（外部命令、内置命令）
- 管道和重定向（`|`, `>`, `<`, `>>`）
- 变量展开（`$VAR`, `${VAR}`）
- 命令替换（`` `command` ``, `$(command)`)
- 算术展开（`$((expr))`）
- 控制流（if/else, for, while, case）
- 函数定义和调用

### 平台限制
- Windows 不支持 `Ctrl+Z` 信号处理（平台限制）
- 某些 Unix 特性在 Windows 上可能表现不同

## 代码审查检查清单

修改代码时，确保：
- [ ] 代码符合 Go 规范（运行 `go fmt`）
- [ ] 没有 linter 错误（运行 `go vet`）
- [ ] 单元测试通过
- [ ] 相关脚本测试通过
- [ ] 平台兼容性（Windows/Linux/macOS）
- [ ] 错误处理正确
- [ ] 添加必要的注释

## 常见命令

### 构建
```bash
go build -o gobash ./cmd/gobash
```

### 运行测试
```bash
go test ./...
./gobash test_all.sh
```

### 代码检查
```bash
go fmt ./...
go vet ./...
```

## 文件结构

```
gobash/
├── cmd/gobash/          # 主程序入口
├── internal/
│   ├── lexer/          # 词法分析器
│   ├── parser/         # 语法分析器
│   ├── executor/       # 执行器
│   ├── builtin/        # 内置命令
│   └── shell/          # Shell 核心逻辑
├── pkg/
│   └── platform/       # 平台相关代码
├── tests/              # 测试脚本目录
│   └── test_*.sh       # 测试脚本
└── .cursorrules        # 本文件
```

## 调试技巧

1. **启用详细输出**：在代码中添加 `fmt.Printf` 调试输出
2. **测试单个功能**：使用 `./gobash -c "command"` 测试单个命令
3. **检查 AST**：在 parser 中添加调试输出来查看 AST 结构
4. **检查 token**：在 lexer 中添加调试输出来查看 token 流

## 性能考虑

- 避免不必要的字符串复制
- 使用 `strings.Builder` 进行字符串拼接
- 对于大量数据，考虑使用流式处理

## 安全考虑

- 执行外部命令时，使用 `exec.Command` 而不是 `os/exec` 的字符串拼接
- 验证用户输入，避免命令注入
- 正确处理文件路径，避免路径遍历攻击

